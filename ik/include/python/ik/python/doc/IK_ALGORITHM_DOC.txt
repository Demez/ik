Algorithm objects have two purposes.
 
First, they control solver  parameters such as the solver type, tolerance, and
maximum number of iterations to use.
 
Secondly,  they define which parts of the tree  should  be  solved.  For  each
effector, segments up to the next algorithm are affected. This means  that  if
you  attach  an algorithm somewhere in the middle of the tree, then the  chain
will terminate  at  the  algorithm  node  rather  than  the root node, even if
e.chain_length  is  longer.  This can be used as a tool to help partition your
tree into different isolated parts.
 
For example:
                              n4
                              ¦          ____
                              n3 <- e1       |
                              |              | This section of
                              n2             | the tree will
                              |              | be solved.
                              n1 <- a1   ____|
                              ¦
                              n0
 
    >>> e1 = n3.effector = ik.Effector()
    >>> a1 = n1.algorithm = ik.Algorithm(ik.TWO_BONE)
 
By  attaching  an  algorithm  to  the node 'n1', nodes 'n1', 'n2' and 'n3' are
marked  as  one chain to be solved by the 'TWO_BONE' algorithm. Nodes 'n0' and
'n3' will be ignored.
 
It is  also possible to change algorithms partway down the tree by attaching a
different algorithm:
 
                              n4
                      ____    ¦
                     |        n3 <- e2
    This section is  |        |
    solved by the    |        n2
    TWO_BONE solver  |        |              ____
                     |____    n1 <- e1, a2       | This section is
                              |                  | solved by the
                              n0 <- a1       ____| ONE_BONE solver
 
    >>> a1 = n0.algorithm = ik.Algorithm(ik.ONE_BONE)
    >>> a2 = n1.algorithm = ik.Algorithm(ik.TWO_BONE)
    >>> e1 = n1.effector = ik.Effector()
    >>> e2 = n3.effector = ik.Effector()
 
All properties can be specified in the constructor. The only required argument
is the algorithm type:
 
    >>> import ik
    >>> ik.Algorithm(type=ik.FABRIK, 
    ...              max_iterations=20,
    ...              tolerance=1e-2,
    ...              constraints=True,
    ...              poles=True,
    ...              target_rotations=True,
    ...              integrate_rk45=True)
 
The available algorithm types are:
  - ik.ONE_BONE
  - ik.TWO_BONE
  - ik.FABRIK
  - ik.MSS

